<<<<<<< HEAD
[
<<<<<<< HEAD
["index.html", "Cryptocurrency Research Section - 1 Introduction 1.1 What will I learn? 1.2 Before Getting Started 1.3 Format Notes 1.4 Who is this tutorial for? 1.5 Plan of Attack 1.6 GitHub Repository 1.7 Disclaimer", " Cryptocurrency Research Last Updated: 2020-10-27 12:41:04 Section - 1 Introduction (this book is a work in progress and is NOT ready) Welcome to this programming tutorial on machine learning! In this tutorial we will use the latest data from the cryptocurrency markets to provide a hands-on and complete example that anyone can follow along with. 1.1 What will I learn? You will primarily learn about tools for the R programming language developed by RStudio and more specifically the tidyverse. If you are not familiar with these open source products, don’t worry. We’ll introduce these throughout the tutorial as needed. The focus of the tutorial is on supervised machine learning, a process for building models that can predict future events, such as cryptocurrency prices. You will learn how to use the caret package to make many different predictive models, and tools to evaluate their performance. Before we can make the models themselves, we will need to “clean” the data. You will learn how to perform “group by” operations on your data using the dplyr package and to clean and modify grouped data. You will learn to visualize data using the ggplot2 package, as well as some powerful tools to extend the functionality of ggplot2. You will gain a better understanding of the steps involved in any supervised machine learning process, as well as considerations you might need to keep in mind based on your specific data and the way you plan on acting on the predictions you have made. Each problem comes with a unique set of challenges, but there are steps that are necessary in creating any supervised machine learning model, and questions you should ask yourself regardless of the specific problem at hand. You will also learn a little about cryptocurrencies themselves, but this is not a tutorial centered around trading or blockchain technology. 1.2 Before Getting Started You can toggle the sidebar on the left side of the page by clicking on the menu button in the top left, or by pressing on the s key on your keyboard. You can read this document as if it were a book, scrolling to the bottom of the page and going to the next “chapter”, or navigating between sections using the sidebar. This document is the tutorial itself, but in order to make the tutorial more accessible to people with less programming experience (or none) we created a high-level version of this tutorial, which simplifies both the problem at hand (what we want to predict) and the specific programming steps, but uses the same tools and methodology providing easier to digest examples that can be applied to many different datasets and problems. 1.2.1 High-Level Version If you are not very familiar with programming in either R or Python, or are not sure what cryptocurrencies are, you should definitely work your way through the high-level version first. If you are an intermediate programmer we still recommend the high-level version first. Below is an embedded version of the high-level version, but we recommend using any of the links given to view it in its own web browser window. 1.3 Format Notes You can hide the sidebar on the left by pressing the s key on your keyboard. Exactly like was done in the high-level version, whenever an R package is referenced, the text will be colored orange. We will discuss R packages and the rest of the terms below later in this document, but if you are not familiar with these terms please look through the high-level version first. Whenever a function is referenced, it will be colored green. Whenever an R object is referenced, it will be colored blue. We will also refer to the parameters of functions in blue. When a term is particularly common in machine learning or data science, we will call it out with purple text, but only the first time it appears. Whenever text is highlighted this way, that means it is a snippet of R code, which will usually be done to bring attention to specific parts of the code. You will not need to login or do anything special to access any of the data or functionality shown here and you will have everything you need to copy each step on your own computer. The cryptocurrency data was chosen to produce results that change over time and because these markets don’t have any downtime (unlike the stock market). 1.4 Who is this tutorial for? Are you a Bob, Hosung, or Jessica below? This section provides an example of how different users may want to approach the tutorial differently based on their levels of experience. Bob (beginner): Bob is someone who understands the idea of predictive analytics at a high level and has heard of cryptocurrencies and is interested in learning more about both, but he has never used R. Bob would definitely want to opt for the more high-level version of this tutorial first and come back to this tutorial after getting hands on experience running the code explained there and understanding what happened in each step. Hosung (intermediate): Hosung is a statistician who learned to use R 10 years ago and understands how to use R and Python but has not used either in several years and he is looking for new powerful and easy tools he can use for his job and research. Hosung would want to start with the high-level version of this tutorial and later return to the detailed tutorial. Jessica (expert): Jessica is a business analyst who has experience with both R and the Tidyverse and uses the pipe operator (%&gt;%) regularly. She is also familiar with functional programming and has worked with nested dataframes. Jessica should move onto the next section of this tutorial directly. 1.5 Plan of Attack How will we generate predictive models to predict cryptocurrency prices? At a high level, here are the steps we will be taking: Setup guide. Installation guide on getting the tools used installed on your machine. Explore data. What is the data we are working with? How “good” is the “quality”? Prepare the data. Make adjustments to “clean” the data based on the findings from the previous section to avoid running into problems when making models to make predictions. Visualize the data. Visualizing the data can be an effective way to understand relationships, trends and outliers before creating predictive models, and is generally useful for many different purposes. Definitely the most fun section! Make predictive models. Now we are ready to take the data available to us and use it to make predictive models that can be used to make predictions about future price movements using the latest data. Evaluate the performance of the models. Before we can use the predictive models to make predictions on the latest data, we need to understand how well we expect them to perform, which is also essential in detecting issues. 1.6 GitHub Repository This tutorial has a public GitHub Repository associated with it, which is not only a website for us to easily distribute all the code behind this document for others to view and use, but also where it actually runs. Every 12 hours, a process gets kicked off on the page associated with our project on GitHub.com and refreshes these results. You can view the latest runs as they execute over time here: https://github.com/ries9112/cryptocurrencyresearch-org/actions If you are running into problems using the code or notice any problems, please let us know by creating an issue on the GitHub repository: https://github.com/ries9112/cryptocurrencyresearch-org/issues Go to the next section for instruction on getting setup to follow along with the code run in the tutorial. You can run every step either in the cloud on your web browser, or in your own R session. You can even make a copy of the GitHub Repository on your computer and run this “book” on the latest data (updated hourly), and make changes wherever you would like. All explained in the next section ➡️ 1.7 Disclaimer This tutorial is made available for learning and educational purposes only and the information to follow does not constitute trading advice in any way shape or form. We avoid giving any advice when it comes to trading strategies, as this is a very complex ecosystem that is out of the scope of this tutorial; we make no attempt in this regard, and if this, rather than data science, is your interest, your time would be better spent following a different tutorial that aims to answer those questions. "]
=======
["index.html", "Cryptocurrency Research Section - 1 Introduction 1.1 What will I learn? 1.2 Before Getting Started 1.3 Format Notes 1.4 Plan of Attack 1.5 GitHub Repository 1.6 Disclaimer", " Cryptocurrency Research Last Updated: 2020-10-26 11:41:28 Section - 1 Introduction (this book is a work in progress and is NOT ready) Welcome to this programming tutorial on machine learning! In this tutorial we will use the latest data from the cryptocurrency markets to provide a hands-on and complete example that anyone can follow along with. 1.1 What will I learn? In this tutorial you will primarily learn about tools for the R programming language developed by RStudio and more specifically the tidyverse. If you are not familiar with these open source products, don’t worry. We’ll introduce these throughout the tutorial as needed. The focus of the tutorial is on supervised machine learning, a process for building models that can predict future events, such as cryptocurrency prices. You will learn how to use the caret package to make many different predictive models, and tools to evaluate their performance. Before we can make the models themselves, we will need to “clean” the data. You will learn how to perform “group by” operations on your data using the dplyr package and to clean and modify grouped data. You will learn to visualize data using the ggplot2 package, as well as some powerful tools to extend the functionality of ggplot2. You will gain a better understanding of the steps involved in any supervised machine learning process, as well as considerations you might need to keep in mind based on your specific data and the way you plan on acting on the predictions you have made. Each problem comes with a unique set of challenges, but there are steps that are necessary in creating any supervised machine learning model, and questions you should ask yourself regardless of the specific problem at hand. You will also learn a little about cryptocurrencies themselves, but this is not a tutorial centered around trading or blockchain technology. 1.2 Before Getting Started You can toggle the sidebar on the left side of the page by clicking on the menu button in the top left, or by pressing on the s key on your keyboard. You can read this document as if it were a book, scrolling to the bottom of the page and going to the next “chapter”, or navigating between sections using the sidebar. This document is the tutorial itself, but in order to make the tutorial more accessible to people with less programming experience (or none) we created a high-level version of this tutorial, which simplifies both the problem at hand (what we want to predict) and the specific programming steps, but uses the same tools and methodology providing easier to digest examples that can be applied to many different datasets and problems. 1.2.1 High-Level Version If you are not very familiar with programming in either R or Python, or are not sure what cryptocurrencies are, you should definitely work your way through the high-level version first. If you are an intermediate programmer we still recommend the high-level version first. Below is an embedded version of the high-level version, but we recommend using any of the links above to view it in its own window. Once in its own window it can be full-screened by pressing on the f button on your keyboard. When following along with the high-level tutorial embedded above, the results will be completely reproducible and the document is static and does not update over time meaning your results will exactly match those shown. The document you are currently reading this text on on the other hand updates every 12 hours. You will be able to access the same data source, but it updates hourly by the 8th minute of every hour with the most recent data, so this document and your results won’t perfectly match. 1.3 Format Notes You can hide the sidebar on the left by pressing the s key on your keyboard. The cryptocurrency data was chosen to produce results that change over time and because these markets don’t have any downtime (unlike the stock market). Whenever an R package is referenced, the text will be colored orange. We will discuss R packages and the rest of the terms below later on in this presentation. Whenever a function is referenced, it will be colored green. Whenever an R object is referenced, it will be colored blue. We will also refer to the parameters of functions in blue. When a term is particularly common in machine learning or data science, we will call it out with purple text, but only the first time it appears. Whenever text is highlighted this way, that means it is a snippet of R code, which will usually be done to bring attention to specific parts of the code. 1.4 Plan of Attack How will we generate predictive models to predict cryptocurrency prices? At a high level, here are the steps we will be taking: Setup guide. Installation guide on getting the tools used installed on your machine. Explore data. What is the data we are working with? How “good” is the “quality”? Prepare the data. Make adjustments to “clean” the data based on the findings from the previous section to avoid running into problems when making models to make predictions. Visualize the data. Visualizing the data can be an effective way to understand relationships, trends and outliers before creating predictive models. Make predictive models. Now we are ready to take the data available to us and use it to make predictive models that can be used to make predictions about future price movements using the latest data. Evaluate the performance of the models. Before we can use the predictive models to make predictions on the latest data, we need to understand how well we expect them to perform, which is also essential in detecting issues. 1.5 GitHub Repository In the next section we will talk more about the GitHub Repository for this tutorial, for now you can check on the latest run history for this document, which is expected to update every 12 hours every day: https://github.com/ries9112/cryptocurrencyresearch-org/actions If you are seeing ✅ associated with the most recent runs at the link above, that means you are looking at a version that refreshed in the last 12 hours. If you are seeing red ❌ on the latest runs, you may be looking at an older analysis, but that should not be the case, check the timestamp at the top of this document to be sure. 1.6 Disclaimer This tutorial is made available for learning and educational purposes only and the information to follow does not constitute trading advice in any way shape or form. We avoid giving any advice when it comes to trading strategies, as this is a very complex ecosystem that is out of the scope of this tutorial; we make no attempt in this regard, and if this, rather than data science, is your interest, your time would be better spent following a different tutorial that aims to answer those questions. "]
>>>>>>> parent of f1ea8be... updates to intro and first three sections. commented out evaluate model perf to get CI to execute
]
=======
[["index.html", "Cryptocurrency Research Section - 1 Introduction 1.1 What will I learn? 1.2 Before Getting Started 1.3 Format Notes 1.4 Plan of Attack 1.5 Disclaimer", " Cryptocurrency Research Last Updated: 2020-10-26 17:08:00 Section - 1 Introduction (this book is a work in progress and is NOT ready) Welcome to this programming tutorial on machine learning! 1.1 What will I learn? In this tutorial you will primarily learn about tools for the R programming language developed by RStudio and more specifically the tidyverse. If you are not familiar with these open source products, don’t worry. We’ll introduce these throughout the tutorial as needed. The focus of the tutorial is on supervised machine learning, a process for building models that can predict future events, such as cryptocurrency prices. You will learn how to use the caret package to make many different predictive models, and tools to evaluate their performance. Before we can make the models themselves, we will need to “clean” the data. You will learn how to perform “group by” operations on your data using the dplyr package and to clean and modify grouped data. You will learn to visualize data using the ggplot2 package, as well as some powerful tools to extend the functionality of ggplot2. You will gain a better understanding of the steps involved in any supervised machine learning process, as well as considerations you might need to keep in mind based on your specific data and the way you plan on acting on the predictions you have made. Each problem comes with a unique set of challenges, but there are steps that are necessary in creating any supervised machine learning model, and questions you should ask yourself regardless of the specific problem at hand. You will also learn a little about cryptocurrencies themselves, but this is not a tutorial centered around trading or blockchain technology. 1.2 Before Getting Started You can toggle the sidebar on the left side of the page by clicking on the menu button in the top left, or by pressing on the s key on your keyboard. You can read this document as if it were a book, scrolling to the bottom of the page and going to the next “chapter”, or navigating between sections using the sidebar. This document is the tutorial itself, but in order to make the tutorial more accessible to people with less programming experience (or none) we created a high-level version of this tutorial, which simplifies both the problem at hand (what we want to predict) and the specific programming steps, but uses the same tools and methodology providing easier to digest examples that can be applied to many different datasets and problems. 1.2.1 High-Level Version If you are not very familiar with programming in either R or Python, or are not sure what cryptocurrencies are, you should definitely work your way through the high-level version first. If you are an intermediate programmer we still recommend the high-level version first. Below is an embedded version of the high-level version, but we recommend using any of the links above to view it in its own window. Once in its own window it can be full-screened by pressing on the f button on your keyboard. When following along with this example, the results will be completely reproducible and the document is static and does not update over time. The document you are currently reading this text on on the other hand updates every 12 hours. You will be able to access the same data source, but it updates hourly by the 8th minute of every hour with the most recent data, so this document and your results won’t perfectly match. 1.3 Format Notes You can hide the sidebar on the left by pressing the s key on your keyboard. When the code is highlighted this way, that means we are referencing an R object of some kind. This will usually be an object in the R session like a dataset, but functions and packages are highlighted in the same way. The cryptocurrency data was chosen to produce results that change over time and because these markets don’t have any downtime (unlike the stock market). 1.4 Plan of Attack How will we generate predictive models to predict cryptocurrency prices? At a high level, here are the steps we will be taking: Setup guide. Installation guide on getting the tools used installed on your machine. Explore data. What is the data we are working with? How “good” is the “quality”? Prepare the data. Make adjustments to “clean” the data based on the findings from the previous section to avoid running into problems when making models to make predictions. Visualize the data. Visualizing the data can be an effective way to understand relationships, trends and outliers before creating predictive models. Make predictive models. Now we are ready to take the data available to us and use it to make predictive models that can be used to make predictions about future price movements using the latest data. Evaluate the performance of the models. Before we can use the predictive models to make predictions on the latest data, we need to understand how well we expect them to perform, which is also essential in detecting issues. 1.5 Disclaimer This tutorial is made available for learning and educational purposes only and the information to follow does not constitute trading advice in any way shape or form. We avoid giving any advice when it comes to trading strategies, as this is a very complex ecosystem that is out of the scope of this tutorial; we make no attempt in this regard, and if this, rather than data science, is your interest, your time would be better spent following a different tutorial that aims to answer those questions. "],["setup.html", "Section - 2 Setup and Installation 2.1 Option 1 - Run in the Cloud 2.2 Option 2 - Run Locally 2.3 Installing and Loading Packages", " Section - 2 Setup and Installation You can follow the tutorial without coding. In that case, you can move on to the next page where the tutorial actually begins. 2.1 Option 1 - Run in the Cloud If you do not currently have R and RStudio installed on your computer, you can run all of the code in a jupyter notebook using an R kernel that we have made available online in this mobile friendly link. This can take up to 30 seconds to load, and once it has you should see a page that looks like this: From here, you can run the code one cell at a time: You can also use Shift + Enter to run an individual code cell Or run all code cells at once (recommended): If you feel lost, you can do a quick interactive walkthrough under Help –&gt; User Interface Tour: 2.2 Option 2 - Run Locally If you want to follow along from your own computer directly (recommended option), please follow the installation instructions below. Afterwards, you will be able to run the code. You only need to follow these instructions once. If you have followed these steps once already, skip ahead to the next section. 2.2.1 Setup R Hopefully you already have R and RStudio installed on your computer. If you don’t have these two programs installed, you will need to: Install R. Install RStudio. This step is optional, but it is very recommended that you use an integrated development environment (IDE) like RStudio as you follow along, rather than using the R console as it was installed in step 1 above. 2.3 Installing and Loading Packages [ADD HERE] describe how to install packages, what they are, etc… like high-level version. install.packages(&#39;pacman&#39;) Load pacman: library(pacman) Install other packages: p_load(&#39;pins&#39;,&#39;tidyverse&#39;,&#39;skimr&#39;,&#39;tsibble&#39;,&#39;doParallel&#39;,&#39;DT&#39;, &#39;caret&#39;,&#39;anytime&#39;, # Data Exploration + Data Prep &#39;ggTimeSeries&#39;,&#39;gifski&#39;,&#39;av&#39;, &#39;magick&#39;, &#39;ggthemes&#39;, &#39;plotly&#39;, &#39;ggpubr&#39;, # VIsualization &#39;ggforce&#39;,&#39;gganimate&#39;, &#39;transformr&#39;, # Visualization continued &#39;xgboost&#39;,&#39;gbm&#39;,&#39;deepnet&#39;) # Predictive Modeling Nice work! Now you have everything you need to follow along with this example. "],["explore-data.html", "Section - 3 Explore the Data 3.1 Pull the Data 3.2 Data Preview 3.3 The definition of a “price” 3.4 Data Quality", " Section - 3 Explore the Data 3.1 Pull the Data The first thing we will need to do is download the latest data. We will do this by using the pins package (Luraschi 2020), which has already been loaded into our session in the previous section. First, we will need to connect to a public GitHub repository (anyone can post their code to the GitHub website and make a “repository” with code for their project) and register the board that the data is pinned to by using the board_register() function: board_register(name = &quot;pins_board&quot;, url = &quot;https://raw.githubusercontent.com/predictcrypto/pins/master/&quot;, board = &quot;datatxt&quot;) By running the board_register() command on the URL where the data is located, we can now “ask” for the data we are interested in, which is called hitBTC_orderbook: cryptodata &lt;- pin_get(name = &quot;hitBTC_orderbook&quot;) The data has been saved to the cryptodata object. 3.2 Data Preview Below is a preview of the data: This is tidy data, meaning: Every column is a variable. Every row is an observation. Every cell is a single value. The data is collected once per hour and includes 120 days worth of data relative to today’s date. Each row is an observation of an individual cryptocurrency, and the same cryptocurrency is tracked on an hourly basis, each time presented as a new row in the dataset. Only the first 2,000 rows of the data are shown in the table above. There are 196194 rows in the actual full dataset. The latest data is from 2020-10-26. 3.3 The definition of a “price” [ADD HERE ABOUT ORDERBOOKS VS. PRICE SHOWN ON A WEBSITE] The price of a cryptocurrency on an exchange is given by the order book, where traders can post trades they want to perform. [KEEP ADDING HERE] 3.4 Data Quality First, let us get a general overview of the data to confirm there are no major data quality issues. There are several ways to do this, including using base R functions (base R meaning anything that comes with the default installation of R when you start up a new session), but we will use the skimr(Waring et al. 2020) package to get a nicely formatted output. We can use skim() on the cryptodata dataframe to get a summary of the data to help locate any potential problems: skim(cryptodata) Table 3.1: Data summary Name cryptodata Number of rows 196194 Number of columns 27 _______________________ Column type frequency: character 5 Date 1 numeric 20 POSIXct 1 ________________________ Group variables Variable type: character skim_variable n_missing complete_rate min max empty n_unique whitespace pair 0 1 5 9 0 210 0 symbol 0 1 2 6 0 210 0 quote_currency 0 1 3 3 0 1 0 pkDummy 379 1 13 13 0 1856 0 pkey 379 1 15 19 0 195535 0 Variable type: Date skim_variable n_missing complete_rate min max median n_unique date 379 1 2020-08-10 2020-10-26 2020-09-19 78 Variable type: numeric skim_variable n_missing complete_rate mean sd p0 p25 p50 p75 p100 hist ask_1_price 43 1 261.07 8868.64 0 0.01 0.06 0.63 999999.0 ▇▁▁▁▁ ask_1_quantity 43 1 218788.60 5372867.95 0 18.00 428.00 3620.00 455776000.0 ▇▁▁▁▁ ask_2_price 81 1 240.82 7635.65 0 0.01 0.06 0.63 999999.0 ▇▁▁▁▁ ask_2_quantity 81 1 225115.78 4372672.09 0 20.00 450.00 5016.00 331298000.0 ▇▁▁▁▁ ask_3_price 155 1 261.44 8462.10 0 0.01 0.06 0.64 999000.0 ▇▁▁▁▁ ask_3_quantity 155 1 280886.47 4879752.06 0 14.00 400.00 7011.00 518082000.0 ▇▁▁▁▁ ask_4_price 186 1 200.27 5223.33 0 0.01 0.07 0.69 999000.0 ▇▁▁▁▁ ask_4_quantity 186 1 309102.24 5265204.68 0 12.00 420.00 7580.00 546546000.0 ▇▁▁▁▁ ask_5_price 202 1 175.08 1355.51 0 0.01 0.07 0.72 20523.8 ▇▁▁▁▁ ask_5_quantity 202 1 318663.95 5684501.39 0 12.00 425.40 8674.97 549312000.0 ▇▁▁▁▁ bid_1_price 218 1 172.36 1344.95 0 0.00 0.05 0.56 20298.0 ▇▁▁▁▁ bid_1_quantity 218 1 166526.52 2748680.38 0 30.40 684.25 7930.00 296583000.0 ▇▁▁▁▁ bid_2_price 277 1 172.19 1344.39 0 0.00 0.05 0.56 20269.5 ▇▁▁▁▁ bid_2_quantity 277 1 171060.21 3250136.61 0 21.00 490.00 6070.00 562697873.0 ▇▁▁▁▁ bid_3_price 279 1 171.87 1343.50 0 0.00 0.05 0.54 20231.5 ▇▁▁▁▁ bid_3_quantity 279 1 232914.60 3295582.67 0 12.00 379.30 6050.00 347366000.0 ▇▁▁▁▁ bid_4_price 279 1 171.49 1342.49 0 0.00 0.04 0.52 20227.4 ▇▁▁▁▁ bid_4_quantity 279 1 297223.73 3773281.61 0 10.00 380.00 7320.00 331285000.0 ▇▁▁▁▁ bid_5_price 280 1 170.95 1340.65 0 0.00 0.04 0.50 20210.4 ▇▁▁▁▁ bid_5_quantity 280 1 357603.75 4696924.65 0 10.00 380.00 8400.00 384159000.0 ▇▁▁▁▁ Variable type: POSIXct skim_variable n_missing complete_rate min max median n_unique date_time_utc 379 1 2020-08-10 04:29:09 2020-10-26 17:03:24 2020-09-19 01:04:33 180441 Move on to the next section, where we make the adjustments necessary to the data before we can start making visualizations and predictive models. References "],["data-prep.html", "Section - 4 Data Prep 4.1 Remove Nulls 4.2 Calculate price_usd Column 4.3 Clean Data by Group 4.4 Calculate Target 4.5 Cross Validation 4.6 Fix Data by Split 4.7 Nest data 4.8 Functional Programming", " Section - 4 Data Prep [ADD HERE] 4.1 Remove Nulls [ADD HERE] (because we can’t do anything without ask_1_price or date_time_utc at the very least being there) Remove any rows where the ask_1_price is Null: cryptodata &lt;- cryptodata[!is.na(cryptodata$ask_1_price), ] And when the date_time_utc is Null: cryptodata &lt;- cryptodata[!is.na(cryptodata$date_time_utc), ] 4.2 Calculate price_usd Column [ADD HERE] Calculate the price_usd using the order books data and taking the cheapest price available from the ask side where at least $15 worth of the cryptocurrency are being sold. [ADD HERE] cryptodata &lt;- mutate(cryptodata, trade_usd_1 = ask_1_price * ask_1_quantity, trade_usd_2 = ask_2_price * ask_2_quantity, trade_usd_3 = ask_3_price * ask_3_quantity, trade_usd_4 = ask_4_price * ask_4_quantity, trade_usd_5 = ask_5_price * ask_5_quantity) We can look at an example [ADD HERE] head(select(cryptodata, symbol, date_time_utc, ask_1_price, ask_1_quantity, trade_usd_1)) ## [90m# A tibble: 6 x 5[39m ## symbol date_time_utc ask_1_price ask_1_quantity trade_usd_1 ## [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;dttm&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m ## [90m1[39m BTC 2020-10-26 [90m00:00:00[39m [4m1[24m[4m3[24m028. 0.181 [4m2[24m355. ## [90m2[39m ETH 2020-10-26 [90m00:00:01[39m 406. 0.4 162. ## [90m3[39m EOS 2020-10-26 [90m00:00:01[39m 2.71 70 190. ## [90m4[39m LTC 2020-10-26 [90m00:00:02[39m 58.8 3.75 221. ## [90m5[39m BSV 2020-10-26 [90m00:00:03[39m 181. 18 [4m3[24m253. ## [90m6[39m ADA 2020-10-26 [90m00:00:04[39m 0.106 775 82.4 If none of the top 5 orders on the order book ask side are for at least $15, exclude the row. [ADD HERE] cryptodata &lt;- mutate(cryptodata, price_usd = case_when( cryptodata$trade_usd_1 &gt;= 15 ~ cryptodata$ask_1_price, cryptodata$trade_usd_2 &gt;= 15 ~ cryptodata$ask_2_price, cryptodata$trade_usd_3 &gt;= 15 ~ cryptodata$ask_3_price, cryptodata$trade_usd_4 &gt;= 15 ~ cryptodata$ask_4_price, cryptodata$trade_usd_5 &gt;= 15 ~ cryptodata$ask_5_price)) Now remove rows where we couldn’t find a price above $15 for any of the 5 cheapest orders in the order book. cryptodata &lt;- na.omit(cryptodata) This step removed 20451 rows on the latest run. 4.3 Clean Data by Group [ADD HERE] …group_by() from the dplyr (Wickham et al. 2020) package… cryptodata &lt;- group_by(cryptodata, symbol) 4.3.1 Remove symbols without enough rows [ADD HERE] cryptodata &lt;- dplyr::filter(cryptodata, n() &gt;= 700) The number of rows for the cryptodata dataset before the filtering step was 175364 and is now 146927. 4.3.2 Remove symbols without data from the last 3 days If there was no data collected for a cryptocurrency over the last 3 day period, let’s exclude that asset from the dataset since we are only looking to model data that is currently flowing through the process. If an asset is removed from the exchange (if a project is a scam for example) or is no longer being actively captured by the data collection process, we can’t make new predictions for it, so might as well exclude these ahead of time as well. cryptodata &lt;- dplyr::filter(cryptodata, max(date) &gt; Sys.Date()-3) The number of rows for the cryptodata dataset before this filtering step was 146927 and is now 104867. 4.4 Calculate Target [TODO - ADD HERE] 4.4.1 Any gaps? [TODO - ADD HERE] 4.4.2 Convert to tsibble … the tsibble package (Wang et al. 2020)… 4.4.2.1 Convert to hourly data and get rid of minutes and seconds … anytime() from the anytime package (Eddelbuettel 2020)… cryptodata$ts_index &lt;- anytime(paste0(cryptodata$pkDummy,&#39;:00:00&#39;)) … distinct() from the dplyr package (Wickham et al. 2020)… cryptodata &lt;- distinct(cryptodata, symbol, ts_index, .keep_all=TRUE) … as_tsibble() from the tsibble package (Wang et al. 2020)… cryptodata &lt;- as_tsibble(cryptodata, index=ts_index, key=symbol) 4.4.3 Scan gaps scan_gaps(cryptodata) ## [90m# A tsibble: 19,676 x 2 [1h] &lt;UTC&gt;[39m ## [90m# Key: symbol [86][39m ## symbol ts_index ## [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;dttm&gt;[39m[23m ## [90m 1[39m ACAT 2020-08-13 [90m22:00:00[39m ## [90m 2[39m ACAT 2020-08-14 [90m20:00:00[39m ## [90m 3[39m ACAT 2020-08-14 [90m21:00:00[39m ## [90m 4[39m ACAT 2020-08-14 [90m22:00:00[39m ## [90m 5[39m ACAT 2020-08-15 [90m01:00:00[39m ## [90m 6[39m ACAT 2020-08-15 [90m02:00:00[39m ## [90m 7[39m ACAT 2020-08-15 [90m03:00:00[39m ## [90m 8[39m ACAT 2020-08-15 [90m04:00:00[39m ## [90m 9[39m ACAT 2020-08-15 [90m05:00:00[39m ## [90m10[39m ACAT 2020-08-15 [90m06:00:00[39m ## [90m# … with 19,666 more rows[39m 4.4.4 Fill gaps cryptodata &lt;- fill_gaps(cryptodata) Now looking at the data again, there are 19676 additional rows that were added as implicitly missing in the data: cryptodata ## [90m# A tsibble: 124,344 x 34 [1h] &lt;UTC&gt;[39m ## [90m# Key: symbol [86][39m ## [90m# Groups: symbol [86][39m ## pair symbol quote_currency ask_1_price ask_1_quantity ask_2_price ## [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m ## [90m 1[39m ACAT… ACAT USD 0.000[4m1[24m[4m9[24m [4m1[24m[4m1[24m[4m8[24m300 0.000[4m2[24m[4m2[24m ## [90m 2[39m ACAT… ACAT USD 0.000[4m1[24m[4m9[24m [4m1[24m[4m1[24m[4m8[24m300 0.000[4m2[24m[4m2[24m ## [90m 3[39m ACAT… ACAT USD 0.000[4m1[24m[4m9[24m [4m1[24m[4m1[24m[4m8[24m300 0.000[4m2[24m[4m2[24m ## [90m 4[39m ACAT… ACAT USD 0.000[4m1[24m[4m9[24m [4m1[24m[4m1[24m[4m8[24m300 0.000[4m2[24m[4m2[24m ## [90m 5[39m ACAT… ACAT USD 0.000[4m1[24m[4m9[24m [4m1[24m[4m1[24m[4m8[24m300 0.000[4m2[24m[4m2[24m ## [90m 6[39m ACAT… ACAT USD 0.000[4m1[24m[4m9[24m [4m1[24m[4m1[24m[4m8[24m300 0.000[4m2[24m[4m2[24m ## [90m 7[39m ACAT… ACAT USD 0.000[4m1[24m[4m9[24m [4m1[24m[4m1[24m[4m8[24m300 0.000[4m2[24m[4m2[24m ## [90m 8[39m ACAT… ACAT USD 0.000[4m1[24m[4m9[24m [4m1[24m[4m1[24m[4m8[24m300 0.000[4m2[24m[4m2[24m ## [90m 9[39m ACAT… ACAT USD 0.000[4m1[24m[4m9[24m [4m1[24m[4m1[24m[4m8[24m300 0.000[4m2[24m[4m2[24m ## [90m10[39m ACAT… ACAT USD 0.000[4m1[24m[4m9[24m [4m1[24m[4m1[24m[4m8[24m300 0.000[4m2[24m[4m2[24m ## [90m# … with 124,334 more rows, and 28 more variables: ask_2_quantity [3m[90m&lt;dbl&gt;[90m[23m,[39m ## [90m# ask_3_price [3m[90m&lt;dbl&gt;[90m[23m, ask_3_quantity [3m[90m&lt;dbl&gt;[90m[23m, ask_4_price [3m[90m&lt;dbl&gt;[90m[23m,[39m ## [90m# ask_4_quantity [3m[90m&lt;dbl&gt;[90m[23m, ask_5_price [3m[90m&lt;dbl&gt;[90m[23m, ask_5_quantity [3m[90m&lt;dbl&gt;[90m[23m,[39m ## [90m# bid_1_price [3m[90m&lt;dbl&gt;[90m[23m, bid_1_quantity [3m[90m&lt;dbl&gt;[90m[23m, bid_2_price [3m[90m&lt;dbl&gt;[90m[23m,[39m ## [90m# bid_2_quantity [3m[90m&lt;dbl&gt;[90m[23m, bid_3_price [3m[90m&lt;dbl&gt;[90m[23m, bid_3_quantity [3m[90m&lt;dbl&gt;[90m[23m,[39m ## [90m# bid_4_price [3m[90m&lt;dbl&gt;[90m[23m, bid_4_quantity [3m[90m&lt;dbl&gt;[90m[23m, bid_5_price [3m[90m&lt;dbl&gt;[90m[23m,[39m ## [90m# bid_5_quantity [3m[90m&lt;dbl&gt;[90m[23m, date_time_utc [3m[90m&lt;dttm&gt;[90m[23m, date [3m[90m&lt;date&gt;[90m[23m, pkDummy [3m[90m&lt;chr&gt;[90m[23m,[39m ## [90m# pkey [3m[90m&lt;chr&gt;[90m[23m, trade_usd_1 [3m[90m&lt;dbl&gt;[90m[23m, trade_usd_2 [3m[90m&lt;dbl&gt;[90m[23m, trade_usd_3 [3m[90m&lt;dbl&gt;[90m[23m,[39m ## [90m# trade_usd_4 [3m[90m&lt;dbl&gt;[90m[23m, trade_usd_5 [3m[90m&lt;dbl&gt;[90m[23m, price_usd [3m[90m&lt;dbl&gt;[90m[23m, ts_index [3m[90m&lt;dttm&gt;[90m[23m[39m For now, let’s convert the data back to a tibble instead of a tsibble: cryptodata &lt;- group_by(as_tibble(cryptodata), symbol) 4.4.5 Calculate Target [ADD HERE] Also adding lagged variables here! [ADD HERE] …mutate() from the dplyr (Wickham et al. 2020) package… cryptodata &lt;- mutate(cryptodata, target_price_24h = lead(price_usd, 24, order_by=ts_index), # Now all the lagged variables: lagged_price_1h = lag(price_usd, 1, order_by=ts_index), lagged_price_2h = lag(price_usd, 2, order_by=ts_index), lagged_price_3h = lag(price_usd, 3, order_by=ts_index), lagged_price_6h = lag(price_usd, 6, order_by=ts_index), lagged_price_12h = lag(price_usd, 12, order_by=ts_index), lagged_price_24h = lag(price_usd, 24, order_by=ts_index)) #lagged_price_3d = lag(price_usd, 24*3, order_by=ts_index), #lagged_price_7d = lag(price_usd, 24*7, order_by=ts_index), #lagged_price_14d = lag(price_usd, 24*14, order_by=ts_index), #lagged_price_31d = lag(price_usd, 24*31, order_by=ts_index)) Here is an example showing the results for the subset of data related to the Ethereum cryptocurrency (using symbol == 'ETH') showing 30 rows and the relevant columns we just calculated: print(select(filter(cryptodata, symbol == &#39;ETH&#39;),ts_index, price_usd, lagged_price_1h, lagged_price_24h, target_price_24h), n=30) ## [90m# A tibble: 1,135 x 6[39m ## [90m# Groups: symbol [1][39m ## symbol ts_index price_usd lagged_price_1h lagged_price_24h ## [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;dttm&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m ## [90m 1[39m ETH 2020-09-09 [90m11:00:00[39m 347. [31mNA[39m [31mNA[39m ## [90m 2[39m ETH 2020-09-09 [90m12:00:00[39m 348. 347. [31mNA[39m ## [90m 3[39m ETH 2020-09-09 [90m13:00:00[39m 347. 348. [31mNA[39m ## [90m 4[39m ETH 2020-09-09 [90m14:00:00[39m 348. 347. [31mNA[39m ## [90m 5[39m ETH 2020-09-09 [90m15:00:00[39m 353. 348. [31mNA[39m ## [90m 6[39m ETH 2020-09-09 [90m16:00:00[39m 353. 353. [31mNA[39m ## [90m 7[39m ETH 2020-09-09 [90m17:00:00[39m 351. 353. [31mNA[39m ## [90m 8[39m ETH 2020-09-09 [90m18:00:00[39m 352. 351. [31mNA[39m ## [90m 9[39m ETH 2020-09-09 [90m19:00:00[39m 359. 352. [31mNA[39m ## [90m10[39m ETH 2020-09-09 [90m20:00:00[39m 356. 359. [31mNA[39m ## [90m11[39m ETH 2020-09-09 [90m21:00:00[39m 353. 356. [31mNA[39m ## [90m12[39m ETH 2020-09-09 [90m22:00:00[39m 353. 353. [31mNA[39m ## [90m13[39m ETH 2020-09-09 [90m23:00:00[39m 355. 353. [31mNA[39m ## [90m14[39m ETH 2020-09-10 [90m00:00:00[39m 351. 355. [31mNA[39m ## [90m15[39m ETH 2020-09-10 [90m01:00:00[39m 355. 351. [31mNA[39m ## [90m16[39m ETH 2020-09-10 [90m02:00:00[39m 368. 355. [31mNA[39m ## [90m17[39m ETH 2020-09-10 [90m03:00:00[39m 367. 368. [31mNA[39m ## [90m18[39m ETH 2020-09-10 [90m04:00:00[39m 371. 367. [31mNA[39m ## [90m19[39m ETH 2020-09-10 [90m05:00:00[39m 373. 371. [31mNA[39m ## [90m20[39m ETH 2020-09-10 [90m06:00:00[39m 370. 373. [31mNA[39m ## [90m21[39m ETH 2020-09-10 [90m07:00:00[39m 367. 370. [31mNA[39m ## [90m22[39m ETH 2020-09-10 [90m08:00:00[39m 363. 367. [31mNA[39m ## [90m23[39m ETH 2020-09-10 [90m09:00:00[39m 364. 363. [31mNA[39m ## [90m24[39m ETH 2020-09-10 [90m10:00:00[39m 365. 364. [31mNA[39m ## [90m25[39m ETH 2020-09-10 [90m11:00:00[39m 363. 365. 347. ## [90m26[39m ETH 2020-09-10 [90m12:00:00[39m 365. 363. 348. ## [90m27[39m ETH 2020-09-10 [90m13:00:00[39m 372. 365. 347. ## [90m28[39m ETH 2020-09-10 [90m14:00:00[39m 377. 372. 348. ## [90m29[39m ETH 2020-09-10 [90m15:00:00[39m 367. 377. 353. ## [90m30[39m ETH 2020-09-10 [90m16:00:00[39m 372. 367. 353. ## [90m# … with 1,105 more rows, and 1 more variable: target_price_24h [3m[90m&lt;dbl&gt;[90m[23m[39m The field target_price_24h shows the value of price_usd 24 hours into the future relative to the row of data. All the lagged_ fields show the price from the past relative to when the data was collected (where lagged_price_1h shows the price 1 hour before the ts_index timestamp of the data). 4.5 Cross Validation [ADD HERE] (explain step below) NEW CV METHOD - need to explain: # Remove rows with null date_time_utc to exclude missing data from next steps cryptodata &lt;- drop_na(cryptodata, date_time_utc) # Counts by symbol cryptodata &lt;- cryptodata %&gt;% group_by(symbol) %&gt;% mutate(tot_rows = n()) # Add row index by symbol cryptodata &lt;- mutate(arrange(cryptodata, date_time_utc), row_id = seq_along(date_time_utc)) # Calculate what rows belong in the first split cryptodata &lt;- cryptodata %&gt;% mutate(split_rows_1 = as.integer(n()/5), split_rows_2 = as.integer(split_rows_1*2), split_rows_3 = as.integer(split_rows_1*3), split_rows_4 = as.integer(split_rows_1*4), split_rows_5 = as.integer(split_rows_1*5)) # Now calculate what split the current row_id belongs into cryptodata &lt;- mutate(cryptodata, split = case_when( row_id &lt;= split_rows_1 ~ 1, row_id &lt;= split_rows_2 ~ 2, row_id &lt;= split_rows_3 ~ 3, row_id &lt;= split_rows_4 ~ 4, row_id &gt; split_rows_4 ~ 5)) # Now figure out train/test groups cryptodata &lt;- cryptodata %&gt;% mutate(train_rows_1 = (as.integer(n()/5))*0.8, test_rows_1 = train_rows_1 + (as.integer(n()/5))*0.2, train_rows_2 = test_rows_1 + train_rows_1, test_rows_2 = train_rows_2 + (as.integer(n()/5))*0.2, train_rows_3 = test_rows_2 + train_rows_1, test_rows_3 = train_rows_3 + (as.integer(n()/5))*0.2, train_rows_4 = test_rows_3 + train_rows_1, test_rows_4 = train_rows_4 + (as.integer(n()/5))*0.2, train_rows_5 = test_rows_4 + train_rows_1, test_rows_5 = train_rows_5 + (as.integer(n()/5))*0.2) # Now assign train/test groups cryptodata &lt;- mutate(cryptodata, training = case_when( row_id &lt;= train_rows_1 ~ &#39;train&#39;, row_id &lt;= test_rows_1 ~ &#39;test&#39;, row_id &lt;= train_rows_2 ~ &#39;train&#39;, row_id &lt;= test_rows_2 ~ &#39;test&#39;, row_id &lt;= train_rows_3 ~ &#39;train&#39;, row_id &lt;= test_rows_3 ~ &#39;test&#39;, row_id &lt;= train_rows_4 ~ &#39;train&#39;, row_id &lt;= test_rows_4 ~ &#39;test&#39;, row_id &lt;= train_rows_5 ~ &#39;train&#39;, row_id &gt; train_rows_5 ~ &#39;holdout&#39;)) # Remove all columns that are no longer needed now cryptodata &lt;- select(cryptodata, -(tot_rows:test_rows_5), -(trade_usd_1:trade_usd_5), -(ask_1_price:bid_5_quantity), -pair, -quote_currency, -pkDummy, -pkey, -ts_index, split) Our data now has the new columns training (train, test or holdout) and split (numbers 1-5) added to it, let’s take a look at the new columns: select(cryptodata, training, split) ## [90m# A tibble: 104,668 x 3[39m ## [90m# Groups: symbol [86][39m ## symbol training split ## [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m ## [90m 1[39m LEO train 1 ## [90m 2[39m GBX train 1 ## [90m 3[39m ACT train 1 ## [90m 4[39m BTG train 1 ## [90m 5[39m ACAT train 1 ## [90m 6[39m LINK train 1 ## [90m 7[39m VET train 1 ## [90m 8[39m IHF train 1 ## [90m 9[39m DGB train 1 ## [90m10[39m RCN train 1 ## [90m# … with 104,658 more rows[39m Notice that even though we left symbol variables out of our selection, because it is part of the way we grouped our data, it was added back in with the message “Adding missing grouping variables symbol”. The data is tied to its groupings when performing all operations until we use ungroup() to undo them. Let’s add the new split column to the way the data is grouped: cryptodata &lt;- group_by(cryptodata, symbol, split) The new field split, helps us split the data into 5 different datasets based on the date, and contains a number from 1-5. The new field training flags the data as being part of the train dataset, or the test (or holdout for the first split) dataset for each of the 5 splits/datasets. Running the same code as before with tail() added, we should see rows associated with the test data of the 5th split (again remember, each of the 5 splits has a training and testing dataset): tail( select(cryptodata, training, split) ) ## [90m# A tibble: 6 x 3[39m ## [90m# Groups: symbol, split [6][39m ## symbol training split ## [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m ## [90m1[39m SWM holdout 5 ## [90m2[39m IPL holdout 5 ## [90m3[39m REP holdout 5 ## [90m4[39m DAY holdout 5 ## [90m5[39m NUT holdout 5 ## [90m6[39m UTT holdout 5 The easiest way to understand these groupings, is to visualize them. In the next section, you will learn powerful tools for visualizing data in R. Do not worry if you do not understand the code below and are not familiar with ggplot(), we will explain this framework in the next section, for now review the charts below and try to follow along with the way we are grouping the data for the predictive models by looking at what the x and y axis represent, as well as the colors. On the x-axis we are plotting the DateTime of when a data point was collected, and on the y-axis the split (1-5) as described in this section. The data is then colored based on the category assigned for the training variable (“train”,“test” or “holdout”). We can visualize the new grouping variables: groups_chart &lt;- ggplot(cryptodata, aes(x = date_time_utc, y = split, color = training)) + geom_point() #+ #scale_y_reverse() # now show the chart we just saved: groups_chart We can check on the groupings for each cryptocurrency by animating the previous chart: library(gganimate) animated_chart &lt;- groups_chart + transition_states(symbol) + ggtitle(&#39;Now showing: {closest_state}&#39;) # show the new animated chart animate(animated_chart, fps = 2) If/when need to slow these down, use this code: (can’t change fps from 1 - or at least be careful, it’s error prone) animate(animated_chart, fps = 1) This is another tool that we will walk through in the next section. It can be a bit hard to tell how many data points there are because they end up looking like lines. Let’s change the plot to use geom_jitter() instead of geom_point(), which will manually offset the points and let us see exactly how many data points there are: animated_chart &lt;- animated_chart + geom_jitter() # show the new animated chart animate(animated_chart, fps = 2) 4.6 Fix Data by Split Now that we have split the data into many different subsets, those subsets themselves may have issues that prevent the predictive models from working as expected. 4.6.1 Zero Variance One of the first models we will make is a simple linear model. The regular R function for this will not work if the data contains any columns that have “zero variance”, meaning the value of the column never changes throughout the data being given to the model. Therefore, let’s fix any issues relating to zero variance columns in any dataset before we change the structure of the data in the step after this one. First change the grouping of the data, we are interested in calculating the zero variance based on the symbol, split and training fields. cryptodata &lt;- group_by(cryptodata, symbol, split, training) Now let’s create a new object called find_zero_var which shows the value of the minimum standard deviation across all columns and calculated based on the grouping of symbol, split and train. find_zero_var &lt;- select(mutate(cryptodata, min_sd = min(sd(price_usd, na.rm=T), sd(target_price_24h, na.rm=T), sd(lagged_price_1h, na.rm=T), sd(lagged_price_2h, na.rm=T), sd(lagged_price_3h, na.rm=T), sd(lagged_price_6h, na.rm=T), sd(lagged_price_12h, na.rm=T), sd(lagged_price_24h, na.rm=T))), min_sd) # Show data find_zero_var ## [90m# A tibble: 104,668 x 4[39m ## [90m# Groups: symbol, split, training [860][39m ## symbol split training min_sd ## [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m ## [90m 1[39m LEO 1 train 0.114 ## [90m 2[39m GBX 1 train 0.002[4m5[24m[4m9[24m ## [90m 3[39m ACT 1 train 0.000[4m6[24m[4m6[24m[4m1[24m ## [90m 4[39m BTG 1 train 0.402 ## [90m 5[39m ACAT 1 train 0.000[4m0[24m[4m1[24m[4m6[24m4 ## [90m 6[39m LINK 1 train 2.06 ## [90m 7[39m VET 1 train 0.000[4m8[24m[4m5[24m[4m2[24m ## [90m 8[39m IHF 1 train 0.003[4m2[24m[4m9[24m ## [90m 9[39m DGB 1 train 0.002[4m0[24m[4m4[24m ## [90m10[39m RCN 1 train 0.014[4m1[24m ## [90m# … with 104,658 more rows[39m Now let’s get to a list of cryptocurrency symbols where the minimum standard deviation across all columns for all splits of the data is 0, which is the list of cryptocurrencies to remove from the data. minimum_sd &lt;- filter(distinct(mutate(group_by(ungroup(find_zero_var), symbol), min_sd = min(min_sd, na.rm=T)), min_sd),min_sd &lt; 0.000001)$symbol # Show result minimum_sd ## [1] &quot;LEO&quot; &quot;GBX&quot; &quot;ACT&quot; &quot;ACAT&quot; &quot;PAXG&quot; &quot;DRT&quot; &quot;DENT&quot; &quot;DAY&quot; &quot;IPL&quot; ## [10] &quot;IHT&quot; &quot;MESH&quot; &quot;NAV&quot; &quot;CUR&quot; &quot;FDZ&quot; &quot;COCOS&quot; &quot;HTML&quot; &quot;REX&quot; &quot;GST&quot; ## [19] &quot;CND&quot; &quot;DCN&quot; &quot;MG&quot; &quot;SWM&quot; &quot;PHX&quot; &quot;CUTE&quot; &quot;BCN&quot; &quot;ELF&quot; &quot;WAXP&quot; ## [28] &quot;BNK&quot; &quot;CHAT&quot; &quot;WIKI&quot; &quot;NEU&quot; &quot;ECA&quot; &quot;JST&quot; &quot;SEELE&quot; &quot;UTT&quot; Now we can remove these symbols from appearing in the dataset: cryptodata &lt;- filter(cryptodata, !(symbol %in% minimum_sd)) In the code above we match all rows where the symbol is part of the minimum_sd object with the list of cryptocurrency symbols to remove from the data, and we then negate the selection using the ! operator to only keep rows with symbols not in the list we found. 4.7 Nest data [ADD HERE] … explain goal and method … First make sure groupings are correct cryptodata &lt;- group_by(cryptodata, symbol, split, training) Example nesting data: nest(cryptodata) ## [90m# A tibble: 510 x 4[39m ## [90m# Groups: symbol, training, split [510][39m ## symbol training split data ## [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;list&gt;[39m[23m ## [90m 1[39m BTG train 1 [90m&lt;tibble [272 × 10]&gt;[39m ## [90m 2[39m LINK train 1 [90m&lt;tibble [200 × 10]&gt;[39m ## [90m 3[39m VET train 1 [90m&lt;tibble [284 × 10]&gt;[39m ## [90m 4[39m IHF train 1 [90m&lt;tibble [224 × 10]&gt;[39m ## [90m 5[39m DGB train 1 [90m&lt;tibble [296 × 10]&gt;[39m ## [90m 6[39m RCN train 1 [90m&lt;tibble [261 × 10]&gt;[39m ## [90m 7[39m LTC train 1 [90m&lt;tibble [296 × 10]&gt;[39m ## [90m 8[39m NUT train 1 [90m&lt;tibble [281 × 10]&gt;[39m ## [90m 9[39m NEXO train 1 [90m&lt;tibble [295 × 10]&gt;[39m ## [90m10[39m XMR train 1 [90m&lt;tibble [295 × 10]&gt;[39m ## [90m# … with 500 more rows[39m First make training data nested: cryptodata_train &lt;- rename(nest(filter(cryptodata, training==&#39;train&#39;)), train_data = &#39;data&#39;) # Now remove training column cryptodata_train &lt;- select(ungroup(cryptodata_train, training), -training) # Fix issues with individual groups of the data cryptodata_train$train_data &lt;- lapply(cryptodata_train$train_data, na.omit) # Remove elements with no rows after na.omit step. CONFIRM THIS WORKS!!! # First add new column with nrow of train dataset cryptodata_train &lt;- group_by(ungroup(mutate(rowwise(cryptodata_train), train_rows = nrow(train_data))), symbol, split) # Remove all symbols where their train data has less than 20 rows at least once symbols_rm &lt;- unique(filter(cryptodata_train, split &lt; 5, train_rows &lt; 20)$symbol) # Remove all data relating to the symbols found above cryptodata_train &lt;- filter(cryptodata_train, ! symbol %in% symbols_rm) # ! is to make %not in% operator # Drop train_rows column cryptodata_train &lt;- select(cryptodata_train, -train_rows) Now nest test data: cryptodata_test &lt;- select(rename(nest(filter(cryptodata, training==&#39;test&#39;)), test_data = &#39;data&#39;), -training) # Now remove training column cryptodata_test &lt;- select(ungroup(cryptodata_test, training), -training) Also do holdout: cryptodata_holdout &lt;- rename(nest(filter(cryptodata, training==&#39;holdout&#39;)), holdout_data = &#39;data&#39;) # Remove split and training columns from holdout cryptodata_holdout &lt;- select(ungroup(cryptodata_holdout, split, training), -split, -training) Now join all nested data into the same dataframe # Join train and test cryptodata_nested &lt;- left_join(cryptodata_train, cryptodata_test,by = c(&quot;symbol&quot;, &quot;split&quot;)) # Join holdout cryptodata_nested &lt;- left_join(cryptodata_nested, cryptodata_holdout, by = c(&quot;symbol&quot;)) New data: cryptodata_nested ## [90m# A tibble: 250 x 5[39m ## [90m# Groups: symbol, split [250][39m ## symbol split train_data test_data holdout_data ## [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;list&gt;[39m[23m [3m[90m&lt;list&gt;[39m[23m [3m[90m&lt;list&gt;[39m[23m ## [90m 1[39m BTG 1 [90m&lt;tibble [235 × 10]&gt;[39m [90m&lt;tibble [69 × 10]&gt;[39m [90m&lt;tibble [71 × 10]&gt;[39m ## [90m 2[39m LINK 1 [90m&lt;tibble [176 × 10]&gt;[39m [90m&lt;tibble [51 × 10]&gt;[39m [90m&lt;tibble [53 × 10]&gt;[39m ## [90m 3[39m VET 1 [90m&lt;tibble [254 × 10]&gt;[39m [90m&lt;tibble [72 × 10]&gt;[39m [90m&lt;tibble [76 × 10]&gt;[39m ## [90m 4[39m IHF 1 [90m&lt;tibble [189 × 10]&gt;[39m [90m&lt;tibble [56 × 10]&gt;[39m [90m&lt;tibble [56 × 10]&gt;[39m ## [90m 5[39m DGB 1 [90m&lt;tibble [272 × 10]&gt;[39m [90m&lt;tibble [75 × 10]&gt;[39m [90m&lt;tibble [75 × 10]&gt;[39m ## [90m 6[39m RCN 1 [90m&lt;tibble [189 × 10]&gt;[39m [90m&lt;tibble [66 × 10]&gt;[39m [90m&lt;tibble [67 × 10]&gt;[39m ## [90m 7[39m LTC 1 [90m&lt;tibble [265 × 10]&gt;[39m [90m&lt;tibble [74 × 10]&gt;[39m [90m&lt;tibble [78 × 10]&gt;[39m ## [90m 8[39m NUT 1 [90m&lt;tibble [257 × 10]&gt;[39m [90m&lt;tibble [71 × 10]&gt;[39m [90m&lt;tibble [73 × 10]&gt;[39m ## [90m 9[39m NEXO 1 [90m&lt;tibble [271 × 10]&gt;[39m [90m&lt;tibble [74 × 10]&gt;[39m [90m&lt;tibble [74 × 10]&gt;[39m ## [90m10[39m XMR 1 [90m&lt;tibble [257 × 10]&gt;[39m [90m&lt;tibble [74 × 10]&gt;[39m [90m&lt;tibble [75 × 10]&gt;[39m ## [90m# … with 240 more rows[39m [ADD HERE - Intro to Visualization and explain we will use grouped data in PredictiveModeling] [ADD HERE - Worth mentioning the fact that some data will be higher quality, etc…? Give more background on those steps as “catch-alls”?] 4.8 Functional Programming Could work with the data using for loops, which is an “object-oriented” approach. Basically, we could take our given option, iterate through every row of the data, and perform operations on each row and subset of the data we are interested in. That is one approach, but instead we will use a different approach using a “functional programming” approach –&gt; References "],["visualization.html", "Section - 5 Visualization 📉 5.1 Basics - ggplot2 5.2 Using Extensions", " Section - 5 Visualization 📉 Making visualizations using ggplot2 is one of the very best tools available in the R ecosystem. The gg in ggplot2 stands for the Grammar of Graphics, which is essentially the idea that many different types of charts share the same underlying building blocks, and that they can be put together in different ways to make charts that look very different from each other. In Hadley’s own words, “a pie chart is just a bar chart drawn in polar coordinates”, “They look very different, but in terms of the grammar they have a lot of underlying similarities.” 5.1 Basics - ggplot2 So how does ggplot2 actually work? “…in most cases you start with ggplot(), supply a dataset and aesthetic mapping (with aes()). You then add on layers (like geom_point() or geom_histogram()), scales (like scale_colour_brewer()), faceting specifications (like facet_wrap()) and coordinate systems (like coord_flip()).” - ggplot2.tidyverse.org/. Let’s break this down step by step. \"start with ggplot(), supply a dataset and aesthetic mapping (with aes()) ggplot(data = cryptodata, aes(x = date_time_utc, y = price_usd)) The chart now shows up but is blank because we need to perform an additional step “You then add on layers (like geom_point() or geom_histogram())…” We can take the exact same code as above and add + geom_point() ggplot(data = cryptodata, aes(x = date_time_utc, y = price_usd)) + # adding geom_point(): geom_point() The most expensive cryptocurrency being shown, BTC in this case, makes it difficult to take a look at any of the other ones. Let’s try zooming-in on a single one by using the same code but making an adjustment to the data parameter to only show data for the cryptocurrency with the symbol ETH, first let’s filter the data down to those results only: eth_data &lt;- subset(cryptodata, symbol == &#39;ETH&#39;) ggplot(data = eth_data, aes(x = date_time_utc, y = price_usd)) + geom_point() The axis automatically adjusted to the new data. This is better, but geom_point() might not be the best choice for this chart, let’s change geom_point with geom_line and see what that looks like: ggplot(data = eth_data, aes(x = date_time_utc, y = price_usd)) + # changing geom_point() into geom_line(): geom_line() Let’s save the results as an object called crypto_chart: crypto_chart &lt;- ggplot(data = eth_data, aes(x = date_time_utc, y = price_usd)) + geom_line() We can add a line showing the trend over time: crypto_chart &lt;- crypto_chart + stat_smooth() crypto_chart One particularly nice aspect of using the ggplot framework, is that we can keep adding as many elements and transformations to the chart as we would like with no limitations. We will not save the next result, but to illustrate this point, we can add a new line showing a linear regression fit going through the data using stat_smooth(method = 'lm'). And let’s also show the individual points in green to show we can keep layering things as much as we want. crypto_chart + # Add linear regression line stat_smooth(method = &#39;lm&#39;, color=&#39;red&#39;) + # Add points geom_point(color=&#39;dark green&#39;, size=0.8) By not providing any method option, the stat_smooth() function defaults to use the method called loess, which shows the local trends, while the lm model fits the best fitting linear regression line for the data as a whole. Of course we can add other components that make a visualization effective, let’s add labels to the chart now: crypto_chart &lt;- crypto_chart + ggtitle(paste(&#39;Price Change Over Time -&#39;, eth_data$symbol), subtitle = paste(&#39;Most recent data collected on:&#39;, max(eth_data$date_time_utc))) + xlab(&#39;Date Time (UTC)&#39;) + ylab(&#39;Price ($)&#39;) # display the new chart crypto_chart The ggplot2 package comes with a large amount of functionality. You can find a full reference of the functions you can use here: https://ggplot2.tidyverse.org/reference/ What makes the ggplot2 package even better is the fact that it also comes with a framework for anyone to develop their own extensions. Meaning there is a lot more functionality that the community has created that can be added in importing other packages that provide extensions to ggplot. 5.2 Using Extensions 5.2.1 ggthemes To use an extension, we just need to import it into our R session like we did with ggplot2 and the rest of the packages we want to use. We already loaded the ggthemes (Arnold 2019) package in the Setup section so we do not need to run library(ggthemes) to import the package into the session. We can apply a theme to the chart now and change the way it looks: crypto_chart &lt;- crypto_chart + theme_economist() # display the new chart crypto_chart See below for a full list of themes you can test. If you followed to this point try running the code crypto_chart + theme_excel() or any of the other options listed below instead of + theme_excel(): https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/ 5.2.2 plotly In some cases, it’s helpful to make a chart responsive to a cursor hovering over it. We can convert any ggplot into an interactive chart by using the plotly (Sievert et al. 2020) package, and it is super easy! We already imported the plotly package in the setup section, so all we need to do is wrap our chart in the function ggplotly(): ggplotly(crypto_chart) # notice that we did not overwrite the crypto_chart object this time If you are not looking to convert a ggplot, plotly also provides its own framework for making charts from scratch, you can find out more about it here: https://plotly.com/r/ 5.2.3 ggpubr The ggpubr (Kassambara 2020) extension provides a lot of functionality that we won’t cover here, but one function we can use from this extension is stat_cor(), which allows us to add a correlation coefficient (R) and p-value to the chart. crypto_chart &lt;- crypto_chart + stat_cor() # Show chart crypto_chart We will dive deeper into these metrics in the section where we evaluate the performance of the models. 5.2.4 ggforce The ggforce package (Pedersen 2020) is a useful tool for annotating charts. We can annotate outliers for example: crypto_chart &lt;- crypto_chart + geom_mark_ellipse(aes(filter = price_usd == max(price_usd), label = date_time_utc, description = paste0(&#39;Price spike to $&#39;, price_usd))) + geom_mark_ellipse(aes(filter = price_usd == min(price_usd), label = date_time_utc, description = paste0(&#39;Price drop to $&#39;, price_usd))) Now view the new chart: crypto_chart When using the geom_mark_ellipse() function we are passing the data argument, the label and the description through the aes() function. We are marking two points, one for the minimum price during the time period, and one for the maximum price. For the first point we filter the data to only the point where the price_usd was equal to the max(price_usd) and add the labels accordingly. The same is done for the second point, but showing the lowest price point for the given date range. 5.2.5 gganimate We can also extend the functionality of ggplot by using the gganimate (Pedersen and Robinson 2020) package, which allows us to create an animated GIF that iterates over groups in the data through the use of the transition_states() function. animated_prices &lt;- ggplot(data = mutate(cryptodata, groups=symbol), aes(x = date_time_utc, y = price_usd)) + geom_point() + transition_states(groups) + stat_smooth() + ggtitle(&#39;Price Over Time&#39;,subtitle = &#39;{closest_state}&#39;) + view_follow() # this adjusts the axis based on the group # Show animation: animated_prices We can slow down the animation by using animate() and choosing the speed in terms of the frames per second (fps)\" animated_prices_result &lt;- animate(animated_prices,fps=1) # show slowed down results animated_prices_result We recommend consulting this documentation for really simple and straightforward examples on using gganimate: https://gganimate.com/articles/gganimate.html 5.2.6 ggTimeSeries The ggTimeSeries (Kothari 2018) package has functionality that is helpful in plotting time series data. We can create a calendar heatmap of the price over time using the ggplot_calendar_heatmap() function. calendar_heatmap &lt;- ggplot_calendar_heatmap(eth_data,&#39;date_time_utc&#39;,&#39;price_usd&#39;) #or do target_percent_change here? calendar_heatmap DoW on the y-axis stands for Day Of the Week To read this chart in the correct date order start from the top left and work your way down and to the right once you reach the bottom of the column. The lighter the color the higher the price on the specific day. 5.2.7 Rayshader The previous chart is helpful, but a color scale like that can be a bit difficult to interpret. We could convert the previous chart into a 3d figure that is easier to visually interpret by using the amazing rayshader (???) package. This document runs automatically through GitHub Actions, which does not have a graphical environment to run the code below, which prevents it from refreshing the results with the latest data. We are showing old results for the Rayshader section below. If you have gotten to this point, run the code below yourself on the latest data to see this amazing package in action! # First remove the title from the legend to avoid visual issues calendar_heatmap &lt;- calendar_heatmap + theme(legend.title = element_blank()) # Add the date to the title to make it clear these refresh twice daily calendar_heatmap &lt;- calendar_heatmap + ggtitle(paste0(&#39;Through: &#39;,substr(max(eth_data$date_time_utc),1,10))) # Convert to 3d plot plot_gg(calendar_heatmap, zoom = 0.60, phi = 35, theta = 45) # Render snapshot render_snapshot(&#39;rayshader_image.png&#39;) # Close RGL (which opens on plot_gg() command in a separate window) rgl.close() This is the same two dimensional calendar heatmap that was made earlier. Because we can programmatically adjust the camera as shown above, that means that we can also create a snapshot, move the camera and take another one, and keep going until we have enough to make it look like a video! This is not difficult to do using the render_movie() function, which will take care of everything behind the scenes for the same plot as before: # This time let&#39;s remove the scale too since we aren&#39;t changing it: calendar_heatmap &lt;- calendar_heatmap + theme(legend.position = &quot;none&quot;) # Same 3d plot as before plot_gg(calendar_heatmap, zoom = 0.60, phi = 35, theta = 45) # Render movie render_movie(&#39;rayshader_video.mp4&#39;) # Close RGL rgl.close() Click on the video below to play the output Video Awesome! Move on to the next section to start making predictive models for the data.. References "],["predictive-modeling.html", "Section - 6 Predictive Modeling 6.1 Example Simple Model 6.2 Caret 6.3 Make Predictions 6.4 Traditional Timeseries", " Section - 6 Predictive Modeling 6.1 Example Simple Model …First need to run example normal lm model, etc… 6.1.1 Using Functional Programming linear_model &lt;- function(df){ lm(price_usd ~ . -date_time_utc -date, data = df) } Can now use it for map() cryptodata_nested %&gt;% mutate(lm_model = map(train_data, linear_model)) ## [90m# A tibble: 250 x 6[39m ## [90m# Groups: symbol, split [250][39m ## symbol split train_data test_data holdout_data lm_model ## [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;list&gt;[39m[23m [3m[90m&lt;list&gt;[39m[23m [3m[90m&lt;list&gt;[39m[23m [3m[90m&lt;list&gt;[39m[23m ## [90m 1[39m BTG 1 [90m&lt;tibble [235 × 10]&gt;[39m [90m&lt;tibble [69 × 10[0m… [90m&lt;tibble [71 × 10[0m… [90m&lt;lm&gt;[39m ## [90m 2[39m LINK 1 [90m&lt;tibble [176 × 10]&gt;[39m [90m&lt;tibble [51 × 10[0m… [90m&lt;tibble [53 × 10[0m… [90m&lt;lm&gt;[39m ## [90m 3[39m VET 1 [90m&lt;tibble [254 × 10]&gt;[39m [90m&lt;tibble [72 × 10[0m… [90m&lt;tibble [76 × 10[0m… [90m&lt;lm&gt;[39m ## [90m 4[39m IHF 1 [90m&lt;tibble [189 × 10]&gt;[39m [90m&lt;tibble [56 × 10[0m… [90m&lt;tibble [56 × 10[0m… [90m&lt;lm&gt;[39m ## [90m 5[39m DGB 1 [90m&lt;tibble [272 × 10]&gt;[39m [90m&lt;tibble [75 × 10[0m… [90m&lt;tibble [75 × 10[0m… [90m&lt;lm&gt;[39m ## [90m 6[39m RCN 1 [90m&lt;tibble [189 × 10]&gt;[39m [90m&lt;tibble [66 × 10[0m… [90m&lt;tibble [67 × 10[0m… [90m&lt;lm&gt;[39m ## [90m 7[39m LTC 1 [90m&lt;tibble [265 × 10]&gt;[39m [90m&lt;tibble [74 × 10[0m… [90m&lt;tibble [78 × 10[0m… [90m&lt;lm&gt;[39m ## [90m 8[39m NUT 1 [90m&lt;tibble [257 × 10]&gt;[39m [90m&lt;tibble [71 × 10[0m… [90m&lt;tibble [73 × 10[0m… [90m&lt;lm&gt;[39m ## [90m 9[39m NEXO 1 [90m&lt;tibble [271 × 10]&gt;[39m [90m&lt;tibble [74 × 10[0m… [90m&lt;tibble [74 × 10[0m… [90m&lt;lm&gt;[39m ## [90m10[39m XMR 1 [90m&lt;tibble [257 × 10]&gt;[39m [90m&lt;tibble [74 × 10[0m… [90m&lt;tibble [75 × 10[0m… [90m&lt;lm&gt;[39m ## [90m# … with 240 more rows[39m 6.2 Caret 6.2.1 Parallel Processing [ADD HERE About R only using one CPU as deafault but can use more enabling parallel processing] library(doParallel) cl &lt;- makePSOCKcluster(12) registerDoParallel(cl) 6.2.2 Functional Programming - here or elsewhere? [ADD HERE] Here use Caret + purrr to make models linear_model_caret &lt;- function(df){ train(price_usd ~ . -date_time_utc -date, data = df, method = &#39;lm&#39;, trControl=trainControl(method=&quot;none&quot;)) } Can now use it for map() cryptodata_nested &lt;- mutate(cryptodata_nested, lm_model = map(train_data, linear_model_caret)) 6.2.3 Cross Validation Within each split we created, we can set caret to perform an additional cross-validation step to allow it to do a minimal level of automated hyperparameter tuning as it creates the models (the more we do the longer it will take). fitControl &lt;- trainControl(## 3-fold CV method = &quot;repeatedcv&quot;, number = 3, ## repeated three times repeats = 3) Now create more generalized version model_caret &lt;- function(df, method_choice){ train(price_usd ~ . -date_time_utc -date, data = df, method = method_choice, trControl=fitControl) } 6.2.4 XGBoost models Will now need to use map2() cryptodata_nested &lt;- mutate(cryptodata_nested, xgb_model = map2(train_data, &quot;xgbLinear&quot;,model_caret)) Can also make a tree based XGBoost model: cryptodata_nested &lt;- mutate(cryptodata_nested, xgbTree_model = map2(train_data, &quot;xgbTree&quot;,model_caret)) [TODO - Reference xgboost documentation. Can I embed it? https://xgboost.readthedocs.io/en/latest/parameter.html] 6.2.5 All Other Models Can use the same function and methodology to keep adding models. Could also all be done in one step adding more arguments to mutate(), but broken up to be verbose and take it step by step. 6.2.5.1 Neural Network models cryptodata_nested &lt;- mutate(cryptodata_nested, nnet_model = map2(train_data, &quot;dnn&quot;, model_caret)) 6.2.5.2 Gradient Boosting Machines [TODO - Here could also mention using preProcess function to do things like center and scale data ] 6.3 Make Predictions [TODO] … first one example… predict(object = cryptodata_nested$lm_model[[1]], newdata = cryptodata_nested$test_data[[1]], na.action = na.pass) ## 1 2 3 4 5 6 7 8 ## 11.05654 11.09091 11.07051 11.09330 11.05006 11.08891 10.99741 10.99686 ## 9 10 11 12 13 14 15 16 ## 11.03800 10.83581 10.89103 10.79074 10.53320 10.45409 10.48493 10.45830 ## 17 18 19 20 21 22 23 24 ## 10.40978 10.42272 10.59847 10.72893 10.76222 10.73135 10.74407 10.72406 ## 25 26 27 28 29 30 31 32 ## 10.74648 10.77055 10.71668 10.69415 10.67777 10.67803 10.69440 10.59237 ## 33 34 35 36 37 38 39 40 ## 10.56117 10.77099 10.87755 10.96344 10.99717 10.84811 10.67961 10.51353 ## 41 42 43 44 45 46 47 48 ## 10.70505 10.67629 10.74824 10.73029 10.57976 10.58773 10.53076 10.55656 ## 49 50 51 52 53 54 55 56 ## 10.59144 NA 10.68546 10.74454 10.76615 10.79065 10.76376 10.81101 ## 57 58 59 60 61 62 63 64 ## 10.81816 10.80359 10.79274 10.86754 10.69457 10.69841 10.72871 10.74713 ## 65 66 67 68 69 ## 10.74754 10.69678 10.83603 10.83576 10.83431 … now make function to use for map make_predictions &lt;- function(model, test){ predict(object = model, newdata = test, na.action = na.pass) } And use map2() to use it to make predictions and create new columns for both the test data and the holdout: cryptodata_nested &lt;- mutate(cryptodata_nested, lm_test_predictions = map2(lm_model, test_data, make_predictions), lm_holdout_predictions = map2(lm_model, holdout_data, make_predictions)) We can view the results: select(cryptodata_nested, lm_test_predictions, lm_holdout_predictions) ## [90m# A tibble: 250 x 4[39m ## [90m# Groups: symbol, split [250][39m ## symbol split lm_test_predictions lm_holdout_predictions ## [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;list&gt;[39m[23m [3m[90m&lt;list&gt;[39m[23m ## [90m 1[39m BTG 1 [90m&lt;dbl [69]&gt;[39m [90m&lt;dbl [71]&gt;[39m ## [90m 2[39m LINK 1 [90m&lt;dbl [51]&gt;[39m [90m&lt;dbl [53]&gt;[39m ## [90m 3[39m VET 1 [90m&lt;dbl [72]&gt;[39m [90m&lt;dbl [76]&gt;[39m ## [90m 4[39m IHF 1 [90m&lt;dbl [56]&gt;[39m [90m&lt;dbl [56]&gt;[39m ## [90m 5[39m DGB 1 [90m&lt;dbl [75]&gt;[39m [90m&lt;dbl [75]&gt;[39m ## [90m 6[39m RCN 1 [90m&lt;dbl [66]&gt;[39m [90m&lt;dbl [67]&gt;[39m ## [90m 7[39m LTC 1 [90m&lt;dbl [74]&gt;[39m [90m&lt;dbl [78]&gt;[39m ## [90m 8[39m NUT 1 [90m&lt;dbl [71]&gt;[39m [90m&lt;dbl [73]&gt;[39m ## [90m 9[39m NEXO 1 [90m&lt;dbl [74]&gt;[39m [90m&lt;dbl [74]&gt;[39m ## [90m10[39m XMR 1 [90m&lt;dbl [74]&gt;[39m [90m&lt;dbl [75]&gt;[39m ## [90m# … with 240 more rows[39m Now we can do the same for the rest of the models: cryptodata_nested &lt;- mutate(cryptodata_nested, # XGBoost: xgb_test_predictions = map2(xgb_model, test_data, make_predictions), xgb_holdout_predictions = map2(xgb_model, holdout_data, make_predictions), # XGBoost Trees: xgbTree_test_predictions = map2(xgbTree_model, test_data, make_predictions), xgbTree_holdout_predictions = map2(xgbTree_model, holdout_data, make_predictions), # Neural Network: nnet_test_predictions = map2(nnet_model, test_data, make_predictions), nnet_holdout_predictions = map2(nnet_model, holdout_data, make_predictions)) Done with the parallel processing now: stopCluster(cl) 6.4 Traditional Timeseries "],["evaluate-model-performance.html", "Section - 7 Evaluate Model Performance", " Section - 7 Evaluate Model Performance –&gt; –&gt; –&gt; –&gt; –&gt; –&gt; –&gt; –&gt; –&gt; –&gt; –&gt; –&gt; –&gt; –&gt; –&gt; –&gt; –&gt; –&gt; –&gt; –&gt; –&gt; –&gt; –&gt; –&gt; –&gt; –&gt; –&gt; –&gt; –&gt; –&gt; "],["time-series.html", "Section - 8 Time Series", " Section - 8 Time Series Add here "],["explain-predictions.html", "Section - 9 Explain Predictions", " Section - 9 Explain Predictions # remove after test! print(&#39;got here&#39;) ## [1] &quot;got here&quot; "],["considerations.html", "Section - 10 Considerations 10.1 Session Information", " Section - 10 Considerations What we have outlined here is a supervised machine learning problem and a practical possible approach to the problem, but the results contained in this document would not translate to real-world results. This tutorial is not meant to show anyone how to trade on the cryptocurrency markets, but rather encourage people to apply these tools to their own data problems, and that is the reason the tutorial stops here (also because we like not getting sued). We stop here before dealing with many difficult execution problems, including but not exclusive to: Finding a trading methodology that makes sense. There are lots of decisions to be made, market or limit orders? Coming up with a good trade execution plan that works consistently is not as easy. …Keep outlining the issues outlined by Chandler, especially relating to low market cap cryptocurrencies 10.1 Session Information Below is information relating to the specific R session that was run. If you are unable to reproduce these steps, find the correct version of the tools to install below: sessionInfo() ## R version 4.0.3 (2020-10-10) ## Platform: x86_64-apple-darwin17.0 (64-bit) ## Running under: macOS Catalina 10.15.7 ## ## Matrix products: default ## BLAS: /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRblas.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRlapack.dylib ## ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ## ## attached base packages: ## [1] parallel stats graphics grDevices utils datasets methods ## [8] base ## ## other attached packages: ## [1] deepnet_0.2 gbm_2.1.8 xgboost_1.0.0.2 transformr_0.1.3 ## [5] gganimate_1.0.5 ggforce_0.3.2 ggpubr_0.4.0 plotly_4.9.2.1 ## [9] ggthemes_4.2.0 magick_2.5.0 av_0.5.1 gifski_0.8.6 ## [13] ggTimeSeries_1.0.1 anytime_0.3.7 caret_6.0-86 lattice_0.20-38 ## [17] DT_0.15 doParallel_1.0.15 iterators_1.0.12 foreach_1.5.0 ## [21] tsibble_0.9.2 skimr_2.1 forcats_0.5.0 stringr_1.4.0 ## [25] dplyr_1.0.2 purrr_0.3.4 readr_1.3.1 tidyr_1.1.1 ## [29] tibble_3.0.4 ggplot2_3.3.2 tidyverse_1.3.0 pins_0.4.0 ## [33] pacman_0.5.1 knitr_1.30 bookdown_0.21 ## ## loaded via a namespace (and not attached): ## [1] readxl_1.3.1 backports_1.1.6 plyr_1.8.6 ## [4] repr_1.1.0 lazyeval_0.2.2 splines_4.0.3 ## [7] crosstalk_1.1.0.1 digest_0.6.25 htmltools_0.5.0 ## [10] fansi_0.4.1 magrittr_1.5 openxlsx_4.2.2 ## [13] recipes_0.1.14 modelr_0.1.6 gower_0.2.1 ## [16] lpSolve_5.6.15 prettyunits_1.1.1 colorspace_1.4-1 ## [19] rappdirs_0.3.1 rvest_0.3.5 haven_2.2.0 ## [22] xfun_0.18 crayon_1.3.4 jsonlite_1.7.1 ## [25] survival_3.1-8 glue_1.4.1 polyclip_1.10-0 ## [28] gtable_0.3.0 ipred_0.9-9 car_3.0-10 ## [31] abind_1.4-5 scales_1.1.1 emo_0.0.0.9000 ## [34] DBI_1.1.0 rstatix_0.6.0 Rcpp_1.0.4.6 ## [37] viridisLite_0.3.0 progress_1.2.2 units_0.6-7 ## [40] foreign_0.8-80 stats4_4.0.3 lava_1.6.7 ## [43] prodlim_2019.11.13 htmlwidgets_1.5.1 httr_1.4.2 ## [46] ellipsis_0.3.1 pkgconfig_2.0.3 farver_2.0.3 ## [49] nnet_7.3-12 dbplyr_1.4.2 utf8_1.1.4 ## [52] labeling_0.3 tidyselect_1.1.0 rlang_0.4.7 ## [55] reshape2_1.4.3 munsell_0.5.0 cellranger_1.1.0 ## [58] tools_4.0.3 cli_2.0.2 generics_0.0.2 ## [61] broom_0.7.2 evaluate_0.14 yaml_2.2.1 ## [64] ModelMetrics_1.2.2.2 fs_1.4.1 zip_2.0.4 ## [67] nlme_3.1-144 xml2_1.3.1 compiler_4.0.3 ## [70] rstudioapi_0.11 filelock_1.0.2 curl_4.3 ## [73] e1071_1.7-4 ggsignif_0.6.0 reprex_0.3.0 ## [76] tweenr_1.0.1 stringi_1.4.6 highr_0.8 ## [79] Matrix_1.2-18 classInt_0.4-3 vctrs_0.3.2 ## [82] pillar_1.4.4 lifecycle_0.2.0 data.table_1.12.8 ## [85] R6_2.4.1 KernSmooth_2.23-16 rio_0.5.16 ## [88] codetools_0.2-16 MASS_7.3-51.5 assertthat_0.2.1 ## [91] withr_2.3.0 mgcv_1.8-31 hms_0.5.3 ## [94] grid_4.0.3 rpart_4.1-15 timeDate_3043.102 ## [97] class_7.3-15 rmarkdown_2.5 carData_3.0-4 ## [100] sf_0.9-6 pROC_1.16.2 lubridate_1.7.8 ## [103] base64enc_0.1-3 "],["archive.html", "Section - 11 Archive 11.1 May 2020", " Section - 11 Archive Below is an archive of this same document from different dates: 11.1 May 2020 May 23, 2020 - Morning May 22, 2020 - Morning May 21, 2020 - Morning May 20, 2020 - Morning May 19, 2020 - Morning May 18, 2020 - Morning "],["references.html", "Section - 12 References 12.1 Resources Used 12.2 Packages used and cited", " Section - 12 References The bookdown package (Xie 2020) was used to produce this document, which was built on top of R Markdown and knitr (???). knitr::write_bib(c(.packages()), &quot;packages.bib&quot;) 12.1 Resources Used 12.1.1 Visualization Section https://www.rayshader.com/ https://github.com/yutannihilation/gghighlight https://github.com/njtierney/rstudioconf20/blob/master/slides/index.Rmd … add rest here 12.1.2 Time Series Section https://stackoverflow.com/questions/42820696/using-prophet-package-to-predict-by-group-in-dataframe-in-r … add rest here 12.2 Packages used and cited Arnold, Jeffrey B. 2019. Ggthemes: Extra Themes, Scales and Geoms for Ggplot2. http://github.com/jrnold/ggthemes. Eddelbuettel, Dirk. 2020. Anytime: Anything to Posixct or Date Converter. http://dirk.eddelbuettel.com/code/anytime.html. Kassambara, Alboukadel. 2020. Ggpubr: Ggplot2 Based Publication Ready Plots. https://rpkgs.datanovia.com/ggpubr/. Kothari, Aditya. 2018. GgTimeSeries: Time Series Visualisations Using the Grammar of Graphics. https://github.com/Ather-Energy/ggTimeSeries. Luraschi, Javier. 2020. Pins: Pin, Discover and Share Resources. https://github.com/rstudio/pins. Pedersen, Thomas Lin. 2020. Ggforce: Accelerating Ggplot2. https://CRAN.R-project.org/package=ggforce. Pedersen, Thomas Lin, and David Robinson. 2020. Gganimate: A Grammar of Animated Graphics. https://CRAN.R-project.org/package=gganimate. Sievert, Carson, Chris Parmer, Toby Hocking, Scott Chamberlain, Karthik Ram, Marianne Corvellec, and Pedro Despouy. 2020. Plotly: Create Interactive Web Graphics via Plotly.js. https://CRAN.R-project.org/package=plotly. Wang, Earo, Di Cook, Rob Hyndman, and Mitchell O’Hara-Wild. 2020. Tsibble: Tidy Temporal Data Frames and Tools. https://tsibble.tidyverts.org. Waring, Elin, Michael Quinn, Amelia McNamara, Eduardo Arino de la Rubia, Hao Zhu, and Shannon Ellis. 2020. Skimr: Compact and Flexible Summaries of Data. https://CRAN.R-project.org/package=skimr. Wickham, Hadley, Romain François, Lionel Henry, and Kirill Müller. 2020. Dplyr: A Grammar of Data Manipulation. https://CRAN.R-project.org/package=dplyr. Xie, Yihui. 2020. Bookdown: Authoring Books and Technical Documents with R Markdown. https://github.com/rstudio/bookdown. References "]]
>>>>>>> 19d607bdabc665b1b8c4b8f17405df8c51845de7
